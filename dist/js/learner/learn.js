// Generated by CoffeeScript 1.8.0
var Learn, app;

app = window.app || {};

Learn = (function() {
  function Learn() {
    var letter, letters, _i, _len, _ref;
    this.$writeLetter = document.querySelector('.write .letter');
    this.predicted = false;
    this.currentSet = app.set;
    letters = [];
    _ref = this.currentSet.letters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      letter = _ref[_i];
      letter = new app.Letter(letter, this.currentSet);
      letters.push(letter);
    }
    this.currentSet.letters = letters;
    document.querySelector('.current-set .info').innerText = this.currentSet.letters.join(', ');
    this.clean();
  }

  Learn.prototype.start = function() {
    var letter, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = this.currentSet.letters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      letter = _ref[_i];
      letter.start();
    }
    _ref1 = this.currentSet.letters;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      letter = _ref1[_j];
      _results.push(letter.recalculate());
    }
    return _results;
  };

  Learn.prototype.getMatrix = function(matrix) {
    if (this.matrix) {
      return this.matrix;
    } else {
      return this.matrix = this.getRealMatrix(matrix || window.canvas.getMatrix());
    }
  };

  Learn.prototype.predict = function() {
    var i, max, sum, _i, _ref;
    this.predictions = this.predirectFromMatrix();
    max = math.max(this.predictions);
    sum = 0;
    for (i = _i = 0, _ref = this.currentSet.letters.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      document.querySelector('#' + this.currentSet.letters[i] + ' .prediction').innerText = this.predictions.get([i, 0]);
      sum += this.predictions.get([i, 0]);
      if (max === this.predictions.get([i, 0])) {
        this.predictedLetter(this.currentSet.letters[i]);
      }
    }
    return document.querySelector('.sum').innerText = "Sum: " + sum;
  };

  Learn.prototype.predictedLetter = function(letter) {
    return document.querySelector('.recognize .letter').innerText = letter;
  };

  Learn.prototype.correct = function(correct_letter, recalculate) {
    var element, letter, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (recalculate == null) {
      recalculate = 1;
    }
    _ref = this.currentSet.letters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      letter = _ref[_i];
      if (letter.char === correct_letter) {
        letter.push(this.getFeatures());
      }
    }
    if (recalculate) {
      _ref1 = this.currentSet.letters;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        letter = _ref1[_j];
        letter.recalculate();
      }
    }
    _ref2 = document.querySelectorAll('.letters-element .prediction');
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      element = _ref2[_k];
      element.innerText = "-";
    }
    canvas.clean();
    return this.clean();
  };

  Learn.prototype.clean = function() {
    this.matrix = null;
    this.predicted = null;
    this.features = null;
    this.printFeatures(math.zeros(this.currentSet.numberOfFeatures));
    return this.predictedLetter('-');
  };

  Learn.prototype.getMaxDims = function(matrix) {
    var bottom, left, right, top;
    top = matrix.size()[1];
    bottom = 0;
    right = 0;
    left = matrix.size()[1];
    matrix.forEach(function(value, index, row) {
      var x, y;
      if (value) {
        x = index[1];
        y = index[0];
        if (x >= right) {
          right = x;
        }
        if (y <= top) {
          top = y;
        }
        if (x <= left) {
          left = x;
        }
        if (y >= bottom) {
          return bottom = y;
        }
      }
    });
    return {
      top: top,
      bottom: bottom,
      right: right,
      left: left,
      xLength: Math.abs(right - left),
      yLength: Math.abs(bottom - top)
    };
  };

  Learn.prototype.getRealMatrix = function(matrix) {
    var dims, new_matrix;
    new_matrix = [];
    dims = this.getMaxDims(matrix);
    new_matrix = this.crop(matrix, dims);
    return {
      dims: dims,
      matrix: new_matrix
    };
  };

  Learn.prototype.crop = function(matrix, borders) {
    var element, new_matrix, row, tmp, x, y, _i, _j, _len, _len1, _ref;
    if (!matrix) {
      matrix = this.getMatrix().matrix;
    }
    new_matrix = [];
    y = 0;
    _ref = matrix._data;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      row = _ref[_i];
      x = 0;
      tmp = [];
      if (y >= borders.top && y <= borders.bottom) {
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          element = row[_j];
          if (x >= borders.left && x <= borders.right) {
            tmp.push(matrix.get([y, x]));
          }
          x += 1;
        }
      }
      if (tmp.length) {
        new_matrix.push(tmp);
      }
      y += 1;
    }
    return math.matrix(new_matrix);
  };

  Learn.prototype.countPixels = function(data) {
    var pixels;
    pixels = {
      positive: 0.0,
      all: 1.0
    };
    data.forEach(function(value, index, matrix) {
      if (value) {
        pixels.positive += 1.0;
      }
      return pixels.all += 1.0;
    });
    return pixels.positive / pixels.all;
  };

  Learn.prototype.matrixPercentages = function(options) {
    var data;
    data = this.getMatrix().matrix;
    return {
      top: Math.round(data.size()[0] * options.top),
      right: Math.round(data.size()[1] * options.right),
      bottom: Math.round(data.size()[0] * options.bottom),
      left: Math.round(data.size()[1] * options.left)
    };
  };

  Learn.prototype.feature1 = function() {
    var dims, smaller;
    smaller = this.crop(null, this.matrixPercentages({
      top: 0,
      bottom: 1,
      left: 0,
      right: 0.3
    }));
    dims = this.getMaxDims(smaller);
    return dims.yLength / smaller.size()[0];
  };

  Learn.prototype.feature2 = function() {
    var dims, smaller;
    smaller = this.crop(null, this.matrixPercentages({
      top: 0.4,
      bottom: 0.6,
      left: 0,
      right: 1
    }));
    dims = this.getMaxDims(smaller);
    return dims.xLength / smaller.size()[1];
  };

  Learn.prototype.getFeatures = function() {
    var feature, features, i, _i, _ref;
    if (this.features) {
      return this.features;
    } else {
      features = [];
      for (i = _i = 1, _ref = this.currentSet.numberOfFeatures; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        feature = this['feature' + (i + this.currentSet.move)]();
        features.push([feature]);
      }
      this.features = math.matrix(features);
      return this.features;
    }
  };

  Learn.prototype.norm = function(features, mi, cov) {
    var detCov, expVal, substraction, tmp;
    substraction = math.subtract(features, mi);
    tmp = math.multiply(math.transpose(substraction), math.inv(cov));
    expVal = math.multiply(tmp, substraction);
    if (expVal) {
      expVal = expVal.get([0, 0]);
    }
    detCov = Math.abs(math.det(cov));
    return 1.0 / (Math.pow(2 * 3.14159265358, this.currentSet.numberOfFeatures / 2) * Math.sqrt(detCov)) * Math.exp(-0.5 * expVal);
  };

  Learn.prototype.predirectFromMatrix = function(features) {
    var formula, i, letter, norm, predicted, _i, _len, _ref;
    if (features == null) {
      features = this.getFeatures();
    }
    this.printFeatures();
    predicted = math.zeros(this.currentSet.letters.length, 1);
    i = 0;
    norm = 0;
    _ref = this.currentSet.letters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      letter = _ref[_i];
      formula = this.norm(features, letter.mi, letter.cov);
      norm += formula * letter.pi;
      predicted.set([i, 0], letter.pi * formula);
      i += 1;
    }
    predicted = predicted.map(function(value, index, matrix) {
      return value / norm;
    });
    return predicted;
  };

  Learn.prototype.printFeatures = function(features) {
    var $elements, i;
    if (features == null) {
      features = this.getFeatures();
    }
    $elements = document.querySelectorAll(".features-element");
    i = 0;
    return features.map(function(value, index, matrix) {
      $elements[i].innerText = value;
      return i += 1;
    });
  };

  return Learn;

})();

window.onload = function() {
  window.Learn = new Learn();
  window.Learn.start();
  return Learn.correct();
};

//# sourceMappingURL=learn.js.map
